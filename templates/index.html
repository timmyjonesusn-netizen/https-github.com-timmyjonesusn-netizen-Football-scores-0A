<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>TimmyApp Playlists</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <!-- pastel yellow -> pale pink glow background -->
  <div class="bg-gradient"></div>

  <!-- floating bubbles layer -->
  <div id="bubble-layer"></div>

  <!-- MAIN CONTENT -->
  <main class="page-shell">
    <section class="playlist-section">
      <div class="section-head">
        <h1 class="section-title">Todayâ€™s Featured Playlist</h1>
        <p class="section-sub">Hand-picked for mood &amp; flow</p>
      </div>

      <!-- CARD: Midnight Neon Cruise -->
      <article class="playlist-card">
        <h2 class="playlist-name">Midnight Neon Cruise</h2>
        <p class="playlist-desc">
          dreamy synth / slow drift / safe for socials
        </p>
      </article>

      <!-- CARD: Southern Heatwave -->
      <article class="playlist-card">
        <h2 class="playlist-name">Southern Heatwave</h2>
        <p class="playlist-desc">
          swagger beat / outlaw country trap / creator-safe
        </p>
      </article>

      <!-- CARD: Halo Pulse -->
      <article class="playlist-card">
        <h2 class="playlist-name">Halo Pulse</h2>
        <p class="playlist-desc">
          angel pads / uplight energy / intro &amp; outro friendly
        </p>
      </article>

      <!-- CARD: Purple Drive -->
      <article class="playlist-card">
        <h2 class="playlist-name">Purple Drive</h2>
        <p class="playlist-desc">
          midtempo glide / neon ride / safe for ads
        </p>
      </article>

      <!-- CARD: Yeti Stomp -->
      <article class="playlist-card">
        <h2 class="playlist-name">Yeti Stomp</h2>
        <p class="playlist-desc">
          heavy bass / crowd hype / walk-in music / promo safe
        </p>
      </article>

    </section>
  </main>

  <!-- BUBBLE SCRIPT -->
  <script>
    // HOW THIS WORKS:
    // we spawn tiny bubbles (<15px) that only float upward.
    // each bubble: random start X, tiny sideways drift, random size,
    // bluish / orange-ish / dark blue with neon ring.
    // after it finishes floating, we recycle it at the bottom again.
    (function () {
      const layer = document.getElementById('bubble-layer');

      const BUBBLE_COUNT = 40; // a lot of little clingy bubbles
      const MIN_SIZE = 6;      // px radius-ish
      const MAX_SIZE = 14;     // px radius-ish
      const DURATION_MIN = 10; // seconds
      const DURATION_MAX = 22; // seconds

      // possible bubble color themes
      const COLOR_SETS = [
        // dark blue bubble w/ electric outline
        {
          fill: 'radial-gradient(circle at 30% 30%, rgba(30,60,255,0.6) 0%, rgba(10,10,40,0.0) 70%)',
          ring: 'rgba(0,150,255,0.8)'
        },
        // orange bubble w/ warm ring
        {
          fill: 'radial-gradient(circle at 30% 30%, rgba(255,140,0,0.55) 0%, rgba(60,20,0,0.0) 70%)',
          ring: 'rgba(255,180,80,0.9)'
        },
        // purple w/ pink hue ring to match neon header
        {
          fill: 'radial-gradient(circle at 30% 30%, rgba(200,0,255,0.5) 0%, rgba(30,0,50,0.0) 70%)',
          ring: 'rgba(255,0,200,0.8)'
        }
      ];

      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function makeBubble() {
        const b = document.createElement('span');
        b.className = 'bubble';

        // random size small
        const size = rand(MIN_SIZE, MAX_SIZE); // px
        b.style.setProperty('--size', size + 'px');

        // random horizontal start (vw)
        const startX = rand(-10, 110); // can start slightly off edge for natural look
        b.style.setProperty('--xStart', startX + 'vw');

        // small sideways drift (clingy sideways wobble, not huge travel)
        const xDrift = rand(-20, 20); // px total horizontal wander
        b.style.setProperty('--xDrift', xDrift + 'px');

        // float duration
        const duration = rand(DURATION_MIN, DURATION_MAX);
        b.style.setProperty('--floatTime', duration + 's');

        // delay so they aren't all synced
        const delay = rand(0, 8);
        b.style.setProperty('--delayTime', delay + 's');

        // choose color theme
        const c = COLOR_SETS[Math.floor(Math.random() * COLOR_SETS.length)];
        b.style.setProperty('--bubbleFill', c.fill);
        b.style.setProperty('--bubbleRing', c.ring);

        // when animation ends (bubble reached top), recycle it
        b.addEventListener('animationend', () => {
          // reset values to "respawn" at bottom
          const newSize = rand(MIN_SIZE, MAX_SIZE);
          b.style.setProperty('--size', newSize + 'px');

          const newStartX = rand(-10, 110);
          b.style.setProperty('--xStart', newStartX + 'vw');

          const newXDrift = rand(-20, 20);
          b.style.setProperty('--xDrift', newXDrift + 'px');

          const newDuration = rand(DURATION_MIN, DURATION_MAX);
          b.style.setProperty('--floatTime', newDuration + 's');

          const newDelay = rand(0, 8);
          b.style.setProperty('--delayTime', newDelay + 's');

          const newColor = COLOR_SETS[Math.floor(Math.random() * COLOR_SETS.length)];
          b.style.setProperty('--bubbleFill', newColor.fill);
          b.style.setProperty('--bubbleRing', newColor.ring);

          // force reflow to restart animation
          b.classList.remove('run');
          // eslint-disable-next-line no-unused-expressions
          b.offsetHeight;
          b.classList.add('run');
        });

        layer.appendChild(b);
      }

      // create all bubbles
      for (let i = 0; i < BUBBLE_COUNT; i++) {
        makeBubble();
      }

      // kick animations after a tiny tick so CSS variables are applied
      requestAnimationFrame(() => {
        const all = layer.querySelectorAll('.bubble');
        all.forEach(b => b.classList.add('run'));
      });
    })();
  </script>
</body>
</html>
